<?php
/**
 * @file
 * Code for the IASC Configuration module.
 */

include_once 'iasc_configuration.features.inc';

/**
 * Process the import of spaces and sections.
 *
 * @param array $options
 *   An associative array of options:
 *   - file      : the path to the csv file
 *   - delimiter : 1 character csv delimiter (default: ';')
 *   - enclosure : character that wraps the data (default: '"')
 *   - delete_all: delete all spaces and sections before import (default: FALSE)
 *
 * @return array
 *   Array of errors or nothing if import is successful.
 */
function iasc_configuration_import($options) {
  $messages = array();

  // Load the file object.
  if (empty($options['file'])) {
    $messages['file'] = t('Missing file.');
    return $messages;
  }

  $file_handle = fopen($options['file'], 'r');
  if ($file_handle === FALSE) {
    $messages['file'] = t('File could not be opened.');
    return $messages;
  }

  $items = array();
  if ($header = fgetcsv($file_handle, 0, $options['delimiter'], $options['enclosure'])) {
    while ($data = fgetcsv($file_handle, 0, $options['delimiter'], $options['enclosure'])) {
      if (is_array($data)) {
        $items[] = array_combine($header, $data);
      }
    }
  }

  if ($items === FALSE) {
    $messages['file'] = t('File had no data.');
    return $messages;
  }

  // Get parent bodies.
  $parent_bodies = iasc_configuration_default_parent_bodies();
  $subsidiary_ids = array();
  foreach ($parent_bodies as $key => $item) {
    if ('Subsidiary Bodies' == $item) {
      $subsidiary_ids[] = $key;
    }
  }

  $message = t("Importing parent bodies...\n");
  $operations[] = array("iasc_configuration_import_spaces",
    array(
      $parent_bodies,
      $message,
      array(),
      $subsidiary_ids,
    ),
  );

  // Break up array of spaces/sections to import into chunks of 10.
  $chunk_size = 10;
  $chunks = array_chunk($items, $chunk_size);
  $count_chunks = count($chunks);

  $i = 0;
  // Import these spaces/sections in chunks.
  foreach ($chunks as $chunk) {
    $i++;

    $details = array(
      '@chunk' => $i,
      '@count' => $count_chunks,
    );

    $message = '';
    if (1 == $i) {
      if ($options['delete_all']) {
        $message .= t("Deleting all spaces and sections prior to importing.\n");
      }
      $details['@size'] = $chunk_size;
      $message .= t("Starting import: chunk @chunk of @count (@size records/chunk)\n", $details);
    }

    $message .= t('(Importing chunk @chunk of @count)', $details);

    $operations[] = array("iasc_configuration_import_spaces",
      array(
        $chunk,
        $message,
        $parent_bodies,
        $subsidiary_ids,
      ),
    );
  }

  // Put all that information into our batch array.
  $batch = array(
    'operations' => $operations,
    'title' => t('Importing !total_lines lines from CSV file "%filename"...', array(
        '%filename'    => $options['file'],
        '!total_lines' => $options['total_lines'],
      )
    ),
    'init_message' => t('Starting to import spaces and sections...'),
    'progress_message' => t('Processed @current out of @total.'),
    'error_message' => t('An error occurred during the import.'),
    'finished' => 'iasc_configuration_import_spaces_finished',
  );

  // Delete all spaces and sections if flag set.
  if ($options['delete_all']) {
    iasc_configuration_delete_all();
  }

  // Set the batch.
  batch_set($batch);
}

/**
 * Updates or saves the new chunk of spaces/sections.
 *
 * @param array $chunk
 *   The current chunk of spaces/sections
 * @param string $message
 *   A helpful message about the status of the batch process.
 * @param array $parent_bodies
 *   An array mapping parent body names to legacy body ids.
 * @param array $context
 *   The context for the batch process
 */
function iasc_configuration_import_spaces($chunk, $message, $parent_bodies, $subsidiary_ids, &$context) {
  $context['message'] = $message;

  foreach ($chunk as $key => $item) {
    if (empty($parent_bodies)) {
      // Parent bodies array does not have the same structure as subspaces csv.
      $item = array($item => $key);
    }

    iasc_configuration_create_node($item, $parent_bodies, $subsidiary_ids, $context);
  }
}

/**
 * Deletes all space and section nodes.
 */
function iasc_configuration_delete_all() {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', array('oa_space', 'oa_section'))
    ->propertyOrderBy('nid', 'ASC');

  $result = $query->execute();
  if ($result['node']) {
    $nids = array_keys($result['node']);
    node_delete_multiple($nids);
  }
}

/**
 * Takes an array and creates a space or section node.
 *
 * @param array $item
 *   An array describing the space or section to create.
 * @param array $parent_bodies
 *   An array mapping parent body names to legacy body ids.
 * @param array &$context
 *   A batch API context.
 *
 * @return object|NULL
 *   Returns the resulting node object if created; otherwise NULL.
 */
function iasc_configuration_create_node($item, $parent_bodies, $subsidiary_ids, &$context) {
  // Check the item array.
  if (!is_array($item)) {
    $context['results']['skipped'][] = "Node import failure: Unreadable node data";
    $message = t('Could not import item: @item', array('@item' => print_r($item, TRUE)));
    watchdog('iasc_configuration', $message, WATCHDOG_ERROR);
    return NULL;
  }

  $title = '';
  // If $parent_bodies is empty, we are importing a parent space.
  if (empty($parent_bodies)) {
    $title = key($item);
    $context['results']['processed'][] = $title;

    $nid = iasc_configuration_get_node_by_name('oa_space', $title, 0);
  }
  else {
    $context['results']['processed'][] = $item['bodyID'];

    // If body, bodydetail, and bodyshort equal NULL, then this is a parent space.
    $is_parent = 'NULL' == $item['body'] &&
      'NULL' == $item['bodydetail'] &&
      'NULL' == $item['bodyshort'];
    if ($is_parent) {
      $nid = iasc_configuration_get_parent_by_legacy_id($item['mainbodyID']);
    }
    else {
      // Get parent nid.
      $legacy_parent = iasc_configuration_get_parent_by_legacy_id($item['mainbodyID']);

      // If bodydetail != NULL, then that's the space name, otherwise use body.
      if (!empty($item['bodydetail']) && $item['bodydetail'] != 'NULL') {
        $title = $item['bodydetail'];
      }
      else {
        $title = $item['body'];
      }

      $nid = iasc_configuration_get_node_by_name('oa_space', $title, $legacy_parent);
    }
  }

  if (empty($nid)) {
    $node = new stdClass();
    $node->title = $title;
    $node->uid = 1;
    $node->status = 1;
    $node->comment = 0;
    $node->promote = FALSE;
    $node->type = 'oa_space';
    $node->language = LANGUAGE_NONE;
  }
  else {
    $node = node_load($nid);
  }

  $time = time();
  // Get created date if available.
  if (!empty($item['bodycreated']) && $item['bodycreated'] != 'NULL') {
    $created = new DateTime($item['bodycreated']);
    $created = $created->getTimestamp();
  }

  // Set created time if this is new.
  if (empty($nid)) {
    $context['results']['new_space'][] = $node->title;
    if (!empty($created)) {
      $node->created = $created;
    }
    else {
      $node->created = $time;
    }
  }
  else {
    if (!empty($created)) {
      $node->created = $created;
    }

    $context['results']['updated_space'][] = $node->title;
  }

  $node->changed = $time;
  $node->path['pathauto'] = TRUE;
  $node->og_user_inheritance[LANGUAGE_NONE][0]['value'] = 1;
  $node->og_roles_permissions[LANGUAGE_NONE][0]['value'] = 0;
  $node->group_access[LANGUAGE_NONE][0]['value'] = 0;

  $space_term = taxonomy_get_term_by_name('Default', 'space_type');
  if ($space_term) {
    $space_term = current($space_term);
    $node->field_oa_space_type[LANGUAGE_NONE][0]['tid'] = $space_term->tid;
  }

  if (!empty($item['bodyshort']) && $item['bodyshort'] != 'NULL') {
    $node->field_short_name[LANGUAGE_NONE][0]['value'] = trim($item['bodyshort']);
  }

  $existing_ids = array();
  $legacy_items = field_get_items('node', $node, 'field_body_legacy_ids');

  if ($legacy_items) {
    foreach ($legacy_items as $id) {
      $existing_ids[] = $id['value'];
    }
  }

  // Store the legacy id of the parent body.
  if (empty($parent_bodies)) {
    $id = array_shift($item);
    if (!in_array($id, $existing_ids)) {
      $node->field_body_legacy_ids[LANGUAGE_NONE][] = array(
        'value' => $id,
      );
    }
  }

  // Store the legacy id of the body. There might be multiple ids.
  if (!empty($item['bodyID'])) {
    if (!in_array($item['mainbodyID'], $existing_ids)) {
      $node->field_legacy_parent_id[LANGUAGE_NONE][0] = array(
        'value' => trim($item['mainbodyID']),
      );
    }

    // Store the legacy name of the body.
    // format = mainbody + body + bodyshort
    $legacy_name = $parent_bodies[$item['mainbodyID']];
    $legacy_name .= !empty($item['body']) && $item['body'] != NULL ?
      " {$item['body']}" : '';
    $legacy_name .= !empty($item['bodyshort']) && $item['bodyshort'] != NULL ?
      " {$item['bodyshort']}" : '';
      $node->field_legacy_space_name[LANGUAGE_NONE][0] = array(
      'value' => trim($legacy_name),
    );
  }

  if (!empty($item['bodyclosed']) && $item['bodyclosed'] != 'NULL') {
    $closed = new DateTime($item['bodyclosed']);
    $node->field_date_closed[LANGUAGE_NONE][0] = array(
      'value' => $closed->format('Y-m-d H:i:s'),
      'timezone' => 'UTC',
      'timezone_db' => 'UTC',
    );
  }

  // Ignore $item['link'] - we will manually update since most won't be included.

  if (!empty($legacy_parent)) {
    $node->oa_parent_space[LANGUAGE_NONE][0]['target_id'] = $legacy_parent;
  }

  // Set Panelizer default.
  $node->field_oa_section_override[LANGUAGE_NONE][0]['value'] = 1;
  $handler = panelizer_entity_plugin_get_handler('node');

  if ('Subsidiary Bodies' == $title || in_array($item['mainbodyID'], $subsidiary_ids)) {
    if (empty($node->panelizer)) {
      $panelizer = $handler->get_default_panelizer_object('oa_space', 'node:oa_space:subsidiary_bodies_default');
      $node->panelizer = $panelizer;
    }
    else {
      $node->panelizer['page_manager']->name = 'node:oa_space:subsidiary_bodies_default';
    }
  }
  else {
    if (empty($node->panelizer)) {
      $panelizer = $handler->get_default_panelizer_object('oa_space', 'node:oa_space:principals_wg_weekly_default');
      $node->panelizer = $panelizer;
    }
    else {
      $node->panelizer['page_manager']->name = 'node:oa_space:principals_wg_weekly_default';
    }
  }

  node_save($node);

  // Add sections to the subspaces - ignore $parent_bodies.
  if (!empty($parent_bodies) && !empty($legacy_parent)) {
    iasc_configuration_update_sections($node->nid, $context);
  }
}

/**
 * Get the space entity by title.
 *
 * @param string $type
 *   The type of the node.
 * @param string $title
 *   The title of the node
 * @param int $space_nid
 *   Optional nid of the parent space
 *
 * @return int
 *   The nid of the node
 */
function iasc_configuration_get_node_by_name($type, $title, $space_nid = 0) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', $type)
    ->propertyCondition('title', $title)
    ->propertyOrderBy('nid', 'ASC')
    ->range(0, 1);

  if ($space_nid) {
    if ($type == 'oa_space') {
      $query->fieldCondition('oa_parent_space', 'target_id', $space_nid, '=');
    }
    else {
      $query->fieldCondition('og_group_ref', 'target_id', $space_nid, '=');
    }
  }

  $result = $query->execute();

  if (isset($result['node'])) {
    $nids = array_keys($result['node']);
    return $nids[0];
  }

  return FALSE;
}

/**
 * Get nid of parent based on the given legacy id.
 *
 * @param int $legacy_id
 *   The legacy id
 *
 * @return int
 *   The nid or FALSE if there's no nid.
 */
function iasc_configuration_get_parent_by_legacy_id($legacy_id) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'oa_space')
    ->fieldCondition('field_body_legacy_ids', 'value', $legacy_id, '=')
    ->propertyOrderBy('nid', 'ASC')
    ->range(0, 1);

  $result = $query->execute();

  if (isset($result['node'])) {
    $nids = array_keys($result['node']);
    return $nids[0];
  }

  return FALSE;
}

/**
 * Callback for when the batch process finishes.
 *
 * @param bool $success
 *   True if the batch process completed without errors.
 * @param array $results
 *   Information about the results set in iasc_configuration_import().
 * @param array $operations
 *   An array of details about the operations.
 */
function iasc_configuration_import_spaces_finished($success, $results, $operations) {
  if ($success) {
    drupal_set_message(count($results['processed']) . ' items processed.');
    drupal_set_message(count($results['new_space']) . ' new spaces imported.');
    drupal_set_message(count($results['updated_space']) . ' spaces updated.');
    drupal_set_message(count($results['new_section']) . ' new sections imported.');
    drupal_set_message(count($results['updated_section']) . ' sections updated.');

    if (count($results['skipped'])) {
      drupal_set_message(count($results['skipped']) . ' spaces/sections were not imported. See log for details.');
    }
  }
  else {
    // $operations contains the operations that remained unprocessed.
    $error_operation = reset($operations);
    $message = t('An error occurred while processing %error_operation with arguments: @arguments',
      array(
        '%error_operation' => $error_operation[0],
        '@arguments' => print_r($error_operation[1],
          TRUE),
      )
    );
    drupal_set_message($message, 'error');
  }
}

/**
 * Get default parent bodies.
 *
 * @return array
 *   An array of the parent bodies and their legacy ids.
 */
function iasc_configuration_default_parent_bodies() {
  // An array of Body Name => body legacy id.
  $init_bodies = array(
    'Working Group' => array(1),
    'Subsidiary Bodies' => array(2, 10, 11, 12, 15, 18, 19, 20, 21),
    'Principals' => array(3),
    'Other' => array(4, 14, 17),
    'Weekly' => array(6),
    'Reference Group' => array(13),
  );

  $parent_bodies = array();
  foreach ($init_bodies as $body_name => $ids) {
    foreach ($ids as $legacy_id) {
      $parent_bodies[$legacy_id] = $body_name;
    }
  }

  return $parent_bodies;
}

/**
 * Get sections nodes based on the parent nid.
 *
 * @param int $space_nid
 *   The parent space nid.
 *
 * @return array|bool
 *   The nid for the section or FALSE if one does not exist.
 */
function iasc_configuration_get_sections_by_parent($space_nid) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'oa_section')
    ->propertyOrderBy('nid', 'ASC')
    ->fieldCondition('og_group_ref', 'target_id', $space_nid, '=');

  $result = $query->execute();

  if (isset($result['node'])) {
    return array_keys($result['node']);
  }

  return FALSE;
}

/**
 * Adds default sections to a space.
 *
 * @param int $parent_nid
 *   The nid for the space.
 * @param array $context
 *   The context array for the batch operation.
 */
function iasc_configuration_update_sections($parent_nid, &$context) {
  // All subspaces have a Documents, Calendar and News Section.
  $section_types = array('Document Section', 'Calendar Section', 'News Section');
  $section_type_terms = array();
  foreach ($section_types as $type) {
    $section_term = taxonomy_get_term_by_name($type, 'section_type');
    if ($section_term) {
      $section_term = current($section_term);
      $section_type_terms[$section_term->name] = $section_term->tid;
    }
  }

  $section_nids = iasc_configuration_get_sections_by_parent($parent_nid);

  if ($section_nids) {
    $subspace_section_tids = array();
    $sections = node_load_multiple($section_nids);
    // Confirm that we have all of the sections:
    foreach ($sections as $section) {
      $subspace_section_tids[] = $section->field_oa_section[LANGUAGE_NONE][0]['tid'];
    }

    $missing_tids = array_diff($section_type_terms, $subspace_section_tids);
    if (!empty($missing_tids)) {
      foreach ($missing_tids as $term_name => $tid) {
        iasc_configuration_add_section($parent_nid, $term_name, $tid);
        $context['results']['new_section'][] = "$$term_name - $parent_nid";
      }

    }

  }
  else {
    // We need to create sections for the first time.
    foreach ($section_type_terms as $term_name => $tid) {
      iasc_configuration_add_section($parent_nid, $term_name, $tid);
      $context['results']['new_section'][] = "$term_name - $parent_nid";
    }
  }
}

/**
 * Adds a section to a space.
 *
 * @param int $parent_nid
 *   The nid of the space.
 * @param string $section_name
 *   The name of the section to be added to the space.
 * @param int $section_tid
 *   The tid for the section to be added to the space.
 */
function iasc_configuration_add_section($parent_nid, $section_name, $section_tid) {
  $node = new stdClass();
  $node->title = $section_name;
  $node->uid = 1;
  $node->status = 1;
  $node->comment = 0;
  $node->promote = FALSE;
  $node->type = 'oa_section';
  $node->language = LANGUAGE_NONE;
  $node->og_group_ref[LANGUAGE_NONE][0]['target_id'] = $parent_nid;
  $node->field_oa_section[LANGUAGE_NONE][0]['tid'] = $section_tid;

  $time = time();
  $node->created = $time;
  $node->changed = $time;
  $node->path['pathauto'] = TRUE;
  $node->og_user_inheritance[LANGUAGE_NONE][0]['value'] = 1;
  $node->og_roles_permissions[LANGUAGE_NONE][0]['value'] = 0;
  $node->group_access[LANGUAGE_NONE][0]['value'] = 0;

  node_save($node);
}
